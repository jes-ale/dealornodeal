import createDebug from 'debug';
import { resolvePath, useLogger, extendPages, addWebpackPlugin, extendWebpackConfig, addVitePlugin, extendViteConfig, defineNuxtModule, isNuxt2, getNuxtVersion, isNuxt3, addPlugin, addTemplate, addComponent, addImports } from '@nuxt/kit';
import { dirname, resolve, parse, join, normalize, relative, isAbsolute } from 'pathe';
import { defu } from 'defu';
import { fileURLToPath, pathToFileURL } from 'node:url';
import { readFileSync as readFileSync$1, promises, constants } from 'node:fs';
import { createHash } from 'node:crypto';
import { parse as parse$1 } from '@babel/parser';
import { encodePath, parseURL, parseQuery, withQuery } from 'ufo';
import { resolveLockfile } from 'pkg-types';
import { transform } from '@mizchi/sucrase';
import { isString, isArray, isRegExp, isFunction, isObject, assign } from '@intlify/shared';
import { genSafeVariableName, genDynamicImport, genImport } from 'knitwork';
import { localizeRoutes, DefaultLocalizeRoutesPrefixable } from 'vue-i18n-routing';
import { parse as parse$2, compileScript } from '@vue/compiler-sfc';
import { walk } from 'estree-walker';
import MagicString from 'magic-string';
import VueI18nWebpackPlugin from '@intlify/unplugin-vue-i18n/webpack';
import VueI18nVitePlugin from '@intlify/unplugin-vue-i18n/vite';
import { createUnplugin } from 'unplugin';

const NUXT_I18N_MODULE_ID = "@nuxtjs/i18n";
const VUE_I18N_PKG = "vue-i18n";
const SHARED_PKG = "@intlify/shared";
const MESSAGE_COMPILER_PKG = "@intlify/message-compiler";
const CORE_BASE_PKG = "@intlify/core-base";
const VUE_I18N_BRIDGE_PKG = "@intlify/vue-i18n-bridge";
const VUE_ROUTER_BRIDGE_PKG = "@intlify/vue-router-bridge";
const VUE_I18N_ROUTING_PKG = "vue-i18n-routing";
const STRATEGY_PREFIX_EXCEPT_DEFAULT = "prefix_except_default";
const DEFAULT_OPTIONS = {
  experimental: {
    jsTsFormatResource: false
  },
  bundle: {
    compositionOnly: true,
    runtimeOnly: false,
    fullInstall: true,
    dropMessageCompiler: false
  },
  compilation: {
    jit: true,
    strictMessage: true,
    escapeHtml: false
  },
  customBlocks: {
    defaultSFCLang: "json",
    globalSFCScope: false
  },
  vueI18n: "",
  locales: [],
  defaultLocale: "",
  defaultDirection: "ltr",
  routesNameSeparator: "___",
  trailingSlash: false,
  defaultLocaleRouteNameSuffix: "default",
  strategy: STRATEGY_PREFIX_EXCEPT_DEFAULT,
  lazy: false,
  langDir: null,
  rootRedirect: null,
  detectBrowserLanguage: {
    alwaysRedirect: false,
    cookieCrossOrigin: false,
    cookieDomain: null,
    cookieKey: "i18n_redirected",
    cookieSecure: false,
    fallbackLocale: "",
    redirectOn: "root",
    useCookie: true
  },
  differentDomains: false,
  baseUrl: "",
  dynamicRouteParams: false,
  customRoutes: "page",
  pages: {},
  skipSettingLocaleOnNavigate: false,
  types: "composition",
  debug: false,
  parallelPlugin: false
};
const NUXT_I18N_TEMPLATE_OPTIONS_KEY = "i18n.options.mjs";
const NUXT_I18N_COMPOSABLE_DEFINE_ROUTE = "defineI18nRoute";
const NUXT_I18N_COMPOSABLE_DEFINE_LOCALE = "defineI18nLocale";
const NUXT_I18N_COMPOSABLE_DEFINE_CONFIG = "defineI18nConfig";
const TS_EXTENSIONS = [".ts", ".cts", ".mts"];
const JS_EXTENSIONS = [".js", ".cjs", ".mjs"];
const EXECUTABLE_EXTENSIONS = [...JS_EXTENSIONS, ...TS_EXTENSIONS];
const NULL_HASH = "00000000";

const debug$9 = createDebug("@nuxtjs/i18n:dirs");
const distDir = dirname(fileURLToPath(import.meta.url));
const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
const pkgDir = resolve(distDir, "..");
const pkgModulesDir = resolve(pkgDir, "./node_modules");
debug$9("distDir", distDir);
debug$9("runtimeDir", runtimeDir);
debug$9("pkgDir", pkgDir);
debug$9("pkgModulesDir", pkgModulesDir);

const PackageManagerLockFiles = {
  "npm-shrinkwrap.json": "npm-legacy",
  "package-lock.json": "npm",
  "yarn.lock": "yarn",
  "pnpm-lock.yaml": "pnpm"
};
async function getPackageManagerType() {
  try {
    const parsed = parse(await resolveLockfile());
    const lockfile = `${parsed.name}${parsed.ext}`;
    if (lockfile == null) {
      return "unknown";
    }
    const type = PackageManagerLockFiles[lockfile];
    return type == null ? "unknown" : type;
  } catch (e) {
    throw e;
  }
}
function formatMessage(message) {
  return `[${NUXT_I18N_MODULE_ID}]: ${message}`;
}
function getNormalizedLocales(locales) {
  locales = locales || [];
  const normalized = [];
  for (const locale of locales) {
    if (isString(locale)) {
      normalized.push({ code: locale, iso: locale });
    } else {
      normalized.push(locale);
    }
  }
  return normalized;
}
const IMPORT_ID_CACHES = /* @__PURE__ */ new Map();
const normalizeWithUnderScore = (name) => name.replace(/-/g, "_").replace(/\./g, "_").replace(/\//g, "_");
function convertToImportId(file) {
  if (IMPORT_ID_CACHES.has(file)) {
    return IMPORT_ID_CACHES.get(file);
  }
  const { dir, base } = parse(file);
  const id = normalizeWithUnderScore(`${dir}/${base}`);
  IMPORT_ID_CACHES.set(file, id);
  return id;
}
async function resolveLocales(path, locales, relativeBase) {
  const files = await Promise.all(locales.flatMap((x) => getLocalePaths(x)).map((x) => resolve(path, x)));
  const find = (f) => files.find((file) => file === resolve(path, f));
  const localesResolved = [];
  for (const { file, ...locale } of locales) {
    const resolved = { ...locale, files: [], meta: void 0 };
    const files2 = getLocaleFiles(locale);
    resolved.meta = files2.map((file2) => {
      const filePath = find(file2.path) ?? "";
      const isCached = filePath ? getLocaleType(filePath) !== "dynamic" : true;
      const parsed = parse(filePath);
      const importKey = join(parsed.root, parsed.dir, parsed.base);
      const key = genSafeVariableName(`locale_${convertToImportId(importKey)}`);
      return {
        path: filePath,
        loadPath: normalize(`${relativeBase}/${file2.path}`),
        type: getLocaleType(filePath),
        hash: getHash(filePath),
        parsed,
        key,
        file: {
          path: file2.path,
          cache: file2.cache ?? isCached
        }
      };
    });
    resolved.files = resolved.meta.map((meta) => meta.file);
    localesResolved.push(resolved);
  }
  return localesResolved;
}
function getLocaleType(path) {
  const ext = parse(path).ext;
  if (EXECUTABLE_EXTENSIONS.includes(ext)) {
    const code = readCode(path, ext);
    const parsed = parseCode(code, path);
    const analyzed = scanProgram(parsed.program);
    if (analyzed === "object") {
      return "static";
    } else if (analyzed === "function" || analyzed === "arrow-function") {
      return "dynamic";
    } else {
      return "unknown";
    }
  } else {
    return "static";
  }
}
const PARSE_CODE_CACHES = /* @__PURE__ */ new Map();
function parseCode(code, path) {
  if (PARSE_CODE_CACHES.has(path)) {
    return PARSE_CODE_CACHES.get(path);
  }
  const parsed = parse$1(code, {
    allowImportExportEverywhere: true,
    sourceType: "module"
  });
  PARSE_CODE_CACHES.set(path, parsed);
  return parsed;
}
function scanProgram(program) {
  let ret = false;
  for (const node of program.body) {
    if (node.type === "ExportDefaultDeclaration") {
      if (node.declaration.type === "ObjectExpression") {
        ret = "object";
        break;
      } else if (node.declaration.type === "CallExpression" && node.declaration.callee.type === "Identifier") {
        const [fnNode] = node.declaration.arguments;
        if (fnNode.type === "FunctionExpression") {
          ret = "function";
          break;
        } else if (fnNode.type === "ArrowFunctionExpression") {
          ret = "arrow-function";
          break;
        }
      }
    }
  }
  return ret;
}
function readCode(absolutePath, ext) {
  let code = readFileSync(absolutePath);
  if (TS_EXTENSIONS.includes(ext)) {
    const out = transform(code, {
      transforms: ["jsx"],
      keepUnusedImports: true
    });
    code = out.code;
  }
  return code;
}
function getLayerRootDirs(nuxt) {
  const layers = nuxt.options._layers;
  return layers.length > 1 ? layers.map((layer) => layer.config.rootDir) : [];
}
async function tryResolve(id, targets, pkgMgr, extension = "") {
  for (const target of targets) {
    if (await isExists(target + extension)) {
      return target;
    }
  }
  throw new Error(`Cannot resolve ${id} on ${pkgMgr}! please install it on 'node_modules'`);
}
function readFileSync(path) {
  return readFileSync$1(path, { encoding: "utf-8" });
}
async function isExists(path) {
  try {
    await promises.access(path, constants.F_OK);
    return true;
  } catch (e) {
    return false;
  }
}
async function resolveVueI18nConfigInfo(options, buildDir, rootDir) {
  const configPathInfo = {
    relativeBase: relative(buildDir, rootDir),
    relative: options.vueI18n ?? "i18n.config",
    absolute: "",
    rootDir,
    hash: NULL_HASH,
    type: "unknown",
    meta: {
      path: "",
      loadPath: "",
      type: "unknown",
      hash: NULL_HASH,
      key: "",
      parsed: { base: "", dir: "", ext: "", name: "", root: "" }
    }
  };
  const absolutePath = await resolvePath(configPathInfo.relative, { cwd: rootDir, extensions: EXECUTABLE_EXTENSIONS });
  if (!await isExists(absolutePath))
    return void 0;
  const parsed = parse(absolutePath);
  const loadPath = join(configPathInfo.relativeBase, relative(rootDir, absolutePath));
  configPathInfo.absolute = absolutePath;
  configPathInfo.type = getLocaleType(absolutePath);
  configPathInfo.hash = getHash(loadPath);
  const key = `${normalizeWithUnderScore(configPathInfo.relative)}_${configPathInfo.hash}`;
  configPathInfo.meta = {
    path: absolutePath,
    type: configPathInfo.type,
    hash: configPathInfo.hash,
    loadPath,
    parsed,
    key
  };
  return configPathInfo;
}
function toCode(code) {
  if (code === null) {
    return `null`;
  }
  if (code === void 0) {
    return `undefined`;
  }
  if (isString(code)) {
    return JSON.stringify(code);
  }
  if (isRegExp(code) && code.toString) {
    return code.toString();
  }
  if (isFunction(code) && code.toString) {
    return `(${code.toString().replace(new RegExp(`^${code.name}`), "function ")})`;
  }
  if (isArray(code)) {
    return `[${code.map((c) => toCode(c)).join(`,`)}]`;
  }
  if (isObject(code)) {
    return stringifyObj(code);
  }
  return code + ``;
}
function stringifyObj(obj) {
  return `Object({${Object.entries(obj).map(([key, value]) => `${JSON.stringify(key)}:${toCode(value)}`).join(`,`)}})`;
}
const PARAM_CHAR_RE = /[\w\d_.]/;
function parseSegment(segment) {
  let state = 0 /* initial */;
  let i = 0;
  let buffer = "";
  const tokens = [];
  function consumeBuffer() {
    if (!buffer) {
      return;
    }
    if (state === 0 /* initial */) {
      throw new Error("wrong state");
    }
    tokens.push({
      type: state === 1 /* static */ ? 0 /* static */ : state === 2 /* dynamic */ ? 1 /* dynamic */ : state === 3 /* optional */ ? 2 /* optional */ : 3 /* catchall */,
      value: buffer
    });
    buffer = "";
  }
  while (i < segment.length) {
    const c = segment[i];
    switch (state) {
      case 0 /* initial */:
        buffer = "";
        if (c === "[") {
          state = 2 /* dynamic */;
        } else {
          i--;
          state = 1 /* static */;
        }
        break;
      case 1 /* static */:
        if (c === "[") {
          consumeBuffer();
          state = 2 /* dynamic */;
        } else {
          buffer += c;
        }
        break;
      case 4 /* catchall */:
      case 2 /* dynamic */:
      case 3 /* optional */:
        if (buffer === "...") {
          buffer = "";
          state = 4 /* catchall */;
        }
        if (c === "[" && state === 2 /* dynamic */) {
          state = 3 /* optional */;
        }
        if (c === "]" && (state !== 3 /* optional */ || buffer[buffer.length - 1] === "]")) {
          if (!buffer) {
            throw new Error("Empty param");
          } else {
            consumeBuffer();
          }
          state = 0 /* initial */;
        } else if (PARAM_CHAR_RE.test(c)) {
          buffer += c;
        } else ;
        break;
    }
    i++;
  }
  if (state === 2 /* dynamic */) {
    throw new Error(`Unfinished param "${buffer}"`);
  }
  consumeBuffer();
  return tokens;
}
const resolveRelativeLocales = (relativeFileResolver, locale, merged) => {
  if (typeof locale === "string")
    return merged ?? { iso: locale, code: locale };
  const { file, files, ...entry } = locale;
  const fileEntries = getLocaleFiles(locale);
  const relativeFiles = relativeFileResolver(fileEntries);
  const mergedLocaleObject = typeof merged === "string" ? void 0 : merged;
  return {
    ...entry,
    ...mergedLocaleObject,
    // @ts-ignore
    files: [...relativeFiles ?? [], ...mergedLocaleObject?.files ?? []]
  };
};
const getLocalePaths = (locale) => {
  if (locale.file != null) {
    return [locale.file].map((x) => typeof x === "string" ? x : x.path);
  }
  if (locale.files != null) {
    return [...locale.files].map((x) => typeof x === "string" ? x : x.path);
  }
  return [];
};
const getLocaleFiles = (locale) => {
  if (locale.file != null) {
    return [locale.file].map((x) => typeof x === "string" ? { path: x, cache: void 0 } : x);
  }
  if (locale.files != null) {
    return [...locale.files].map((x) => typeof x === "string" ? { path: x, cache: void 0 } : x);
  }
  return [];
};
const localeFilesToRelative = (projectLangDir, layerLangDir = "", files = []) => {
  const absoluteFiles = files.map((file) => ({ path: resolve(layerLangDir, file.path), cache: file.cache }));
  const relativeFiles = absoluteFiles.map((file) => ({ path: relative(projectLangDir, file.path), cache: file.cache }));
  return relativeFiles;
};
const getProjectPath = (nuxt, ...target) => {
  const projectLayer = nuxt.options._layers[0];
  return resolve(projectLayer.config.rootDir, ...target);
};
const mergeConfigLocales = (configs, baseLocales = []) => {
  const mergedLocales = /* @__PURE__ */ new Map();
  baseLocales.forEach((locale) => mergedLocales.set(locale.code, locale));
  const getLocaleCode = (val) => typeof val === "string" ? val : val.code;
  for (const { locales, langDir, projectLangDir } of configs) {
    if (locales == null)
      continue;
    for (const locale of locales) {
      const code = getLocaleCode(locale);
      const filesResolver = (files) => localeFilesToRelative(projectLangDir, langDir ?? "", files);
      const resolvedLocale = resolveRelativeLocales(filesResolver, locale, mergedLocales.get(code));
      if (resolvedLocale != null)
        mergedLocales.set(code, resolvedLocale);
    }
  }
  return Array.from(mergedLocales.values());
};
const mergeI18nModules = async (options, nuxt) => {
  if (options)
    options.i18nModules = [];
  const registerI18nModule = (config) => {
    if (config.langDir == null)
      return;
    options?.i18nModules?.push(config);
  };
  await nuxt.callHook("i18n:registerModule", registerI18nModule);
  const modules = options?.i18nModules ?? [];
  const projectLangDir = getProjectPath(nuxt, nuxt.options.rootDir);
  if (modules.length > 0) {
    const baseLocales = [];
    const layerLocales = options.locales ?? [];
    for (const locale of layerLocales) {
      if (typeof locale !== "object")
        continue;
      baseLocales.push({ ...locale, file: void 0, files: getLocaleFiles(locale) });
    }
    const mergedLocales = mergeConfigLocales(
      modules.map((x) => ({ ...x, projectLangDir })),
      baseLocales
    );
    options.locales = mergedLocales;
  }
};
function getRoutePath(tokens) {
  return tokens.reduce((path, token) => {
    return path + (token.type === 2 /* optional */ ? `:${token.value}?` : token.type === 1 /* dynamic */ ? `:${token.value}` : token.type === 3 /* catchall */ ? `:${token.value}(.*)*` : encodePath(token.value));
  }, "/");
}
function getHash(text) {
  return createHash("sha256").update(text).digest("hex").substring(0, 8);
}
function getLayerI18n(configLayer) {
  const layerInlineOptions = (configLayer.config.modules || []).find(
    (mod) => isArray(mod) && typeof mod[0] === "string" && [NUXT_I18N_MODULE_ID, `${NUXT_I18N_MODULE_ID}-edge`].includes(mod[0])
  )?.[1];
  if (configLayer.config.i18n) {
    return defu(configLayer.config.i18n, layerInlineOptions);
  }
  return layerInlineOptions;
}
const applyOptionOverrides = (options, nuxt) => {
  const project = nuxt.options._layers[0];
  const { overrides, ...mergedOptions } = options;
  if (overrides) {
    delete options.overrides;
    project.config.i18n = defu(overrides, project.config.i18n);
    Object.assign(options, defu(overrides, mergedOptions));
  }
};

const debug$8 = createDebug("@nuxtjs/i18n:alias");
async function setupAlias(nuxt, options) {
  const pkgMgr = await getPackageManagerType();
  debug$8("setupAlias: pkgMgr", pkgMgr);
  nuxt.options.alias[VUE_I18N_PKG] = await resolveVueI18nAlias(pkgModulesDir, options, nuxt, pkgMgr);
  nuxt.options.build.transpile.push(VUE_I18N_PKG);
  debug$8("vue-i18n alias", nuxt.options.alias[VUE_I18N_PKG]);
  nuxt.options.alias[SHARED_PKG] = await resolveSharedAlias(pkgModulesDir, nuxt, pkgMgr);
  nuxt.options.build.transpile.push(SHARED_PKG);
  debug$8("@intlify/shared alias", nuxt.options.alias[SHARED_PKG]);
  nuxt.options.alias["@intlify/message-compiler"] = await resolveMessageCompilerAlias(pkgModulesDir, nuxt, pkgMgr);
  nuxt.options.build.transpile.push(MESSAGE_COMPILER_PKG);
  debug$8("@intlify/message-compiler alias", nuxt.options.alias[MESSAGE_COMPILER_PKG]);
  nuxt.options.alias["@intlify/core-base"] = await resolveCoreBaseAlias(pkgModulesDir, nuxt, pkgMgr);
  nuxt.options.build.transpile.push(CORE_BASE_PKG);
  debug$8("@intlify/core-base alias", nuxt.options.alias[CORE_BASE_PKG]);
  nuxt.options.alias[VUE_ROUTER_BRIDGE_PKG] = await resolveVueRouterBridgeAlias(pkgModulesDir, nuxt, pkgMgr);
  nuxt.options.build.transpile.push(VUE_ROUTER_BRIDGE_PKG);
  debug$8("@intlify/vue-router-bridge alias", nuxt.options.alias[VUE_ROUTER_BRIDGE_PKG]);
  nuxt.options.alias[VUE_I18N_BRIDGE_PKG] = await resolveVueI18nBridgeAlias(pkgModulesDir, nuxt, pkgMgr);
  nuxt.options.build.transpile.push(VUE_I18N_BRIDGE_PKG);
  debug$8("@intlify/vue-i18n-bridge alias", nuxt.options.alias[VUE_I18N_BRIDGE_PKG]);
  nuxt.options.alias[VUE_I18N_ROUTING_PKG] = await resolveVueI18nRoutingAlias(pkgModulesDir, nuxt, pkgMgr);
  nuxt.options.build.transpile.push(VUE_I18N_ROUTING_PKG);
  debug$8("vue-i18n-routing alias", nuxt.options.alias[VUE_I18N_ROUTING_PKG]);
}
async function resolveVueI18nAlias(pkgModulesDir2, options, nuxt, pkgMgr) {
  const { rootDir, workspaceDir } = nuxt.options;
  const runtimeOnly = options.bundle?.runtimeOnly;
  const modulePath = nuxt.options.dev || nuxt.options._prepare ? `${VUE_I18N_PKG}/dist/vue-i18n.mjs` : `${VUE_I18N_PKG}/dist/vue-i18n${runtimeOnly ? ".runtime" : ""}.mjs`;
  const targets = [
    // for Nuxt layer
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, "node_modules", modulePath)),
    // try to resolve from `node_modules/@nuxtjs/i18n/node_modules` (not hoisted case)
    resolve(pkgModulesDir2, modulePath),
    // try to resolve from `node_modules` (hoisted case)
    resolve(rootDir, "node_modules", modulePath),
    // workspace directories
    resolve(workspaceDir, "node_modules", modulePath)
  ];
  debug$8(`${VUE_I18N_PKG} resolving from ...`, targets);
  return tryResolve(VUE_I18N_PKG, targets, pkgMgr);
}
async function resolveSharedAlias(pkgModulesDir2, nuxt, pkgMgr) {
  const { rootDir, workspaceDir } = nuxt.options;
  const modulePath = `${SHARED_PKG}/dist/shared.mjs`;
  const targets = [
    // for Nuxt layer
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, `${VUE_I18N_PKG}/node_modules`, modulePath)),
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, `${MESSAGE_COMPILER_PKG}/node_modules`, modulePath)),
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, "node_modules", modulePath)),
    // try to resolve from `node_modules/@nuxtjs/i18n/node_modules` (not hoisted case)
    resolve(pkgModulesDir2, modulePath),
    // try to resolve from `node_modules/@nuxtjs/i18n/node_modules/vue-i18n/node_modules` (not hoisted case)
    resolve(pkgModulesDir2, `${VUE_I18N_PKG}/node_modules`, modulePath),
    // try to resolve from `node_modules/@nuxtjs/i18n/node_modules/@intlify/message-compiler/node_modules` (not hoisted case)
    resolve(pkgModulesDir2, `${MESSAGE_COMPILER_PKG}/node_modules`, modulePath),
    // try to resolve from `node_modules` (hoisted case)
    resolve(rootDir, "node_modules", modulePath),
    // workspace directories
    resolve(workspaceDir, "node_modules", `${VUE_I18N_PKG}/node_modules`, modulePath),
    resolve(workspaceDir, "node_modules", `${MESSAGE_COMPILER_PKG}/node_modules`, modulePath),
    resolve(workspaceDir, "node_modules", modulePath)
  ];
  debug$8(`${SHARED_PKG} resolving from ...`, targets);
  return tryResolve(SHARED_PKG, targets, pkgMgr);
}
async function resolveCoreBaseAlias(pkgModulesDir2, nuxt, pkgMgr) {
  const { rootDir, workspaceDir } = nuxt.options;
  const modulePath = `${CORE_BASE_PKG}/dist/core-base.mjs`;
  const targets = [
    // for Nuxt layer
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, "node_modules", modulePath)),
    // try to resolve from `node_modules/@nuxtjs/i18n` (not hoisted case)
    resolve(pkgModulesDir2, modulePath),
    // try to resolve from `node_modules` (hoisted case)
    resolve(rootDir, "node_modules", modulePath),
    // workspace directories
    resolve(workspaceDir, "node_modules", modulePath)
  ];
  debug$8(`${CORE_BASE_PKG} resolving from ...`, targets);
  return tryResolve(CORE_BASE_PKG, targets, pkgMgr);
}
async function resolveMessageCompilerAlias(pkgModulesDir2, nuxt, pkgMgr) {
  const { rootDir, workspaceDir } = nuxt.options;
  const modulePath = `${MESSAGE_COMPILER_PKG}/dist/message-compiler.mjs`;
  const targets = [
    // for Nuxt layer
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, "node_modules", modulePath)),
    // try to resolve from `node_modules/@nuxtjs/i18n` (not hoisted case)
    resolve(pkgModulesDir2, modulePath),
    // try to resolve from `node_modules` (hoisted case)
    resolve(rootDir, "node_modules", modulePath),
    // workspace directories
    resolve(workspaceDir, "node_modules", modulePath)
  ];
  debug$8(`${MESSAGE_COMPILER_PKG} resolving from ...`, targets);
  return tryResolve(MESSAGE_COMPILER_PKG, targets, pkgMgr);
}
async function resolveVueI18nBridgeAlias(pkgModulesDir2, nuxt, pkgMgr) {
  const { rootDir, workspaceDir } = nuxt.options;
  const modulePath = `${VUE_I18N_BRIDGE_PKG}/lib/index.mjs`;
  const targets = [
    // for Nuxt layer
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath)),
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, "node_modules", modulePath)),
    // try to resolve from `node_modules/@nuxtjs/i18n` (not hoisted case)
    resolve(pkgModulesDir2, modulePath),
    // try to resolve from `node_modules/@nuxtjs/i18n/node_modules/vue-i18n-routing` (not hoisted case)
    resolve(pkgModulesDir2, `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath),
    // try to resolve from `node_modules/vue-i18n-routing` (hoisted case)
    resolve(rootDir, "node_modules", `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath),
    // try to resolve from `node_modules` (hoisted case)
    resolve(rootDir, "node_modules", modulePath),
    // workspace directories
    resolve(workspaceDir, "node_modules", `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath),
    resolve(workspaceDir, "node_modules", modulePath)
  ];
  debug$8(`${VUE_I18N_BRIDGE_PKG} resolving from ...`, targets);
  return tryResolve(VUE_I18N_BRIDGE_PKG, targets, pkgMgr);
}
async function resolveVueRouterBridgeAlias(pkgModulesDir2, nuxt, pkgMgr) {
  const { rootDir, workspaceDir } = nuxt.options;
  const modulePath = `${VUE_ROUTER_BRIDGE_PKG}/lib/index.mjs`;
  const targets = [
    // for Nuxt layer
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath)),
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, "node_modules", modulePath)),
    // try to resolve from `node_modules/@nuxtjs/i18n` (not hoisted case)
    resolve(pkgModulesDir2, modulePath),
    // try to resolve from `node_modules/@nuxtjs/i18n/node_modules/vue-i18n-routing` (not hoisted case)
    resolve(pkgModulesDir2, `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath),
    // try to resolve from `node_modules/vue-i18n-routing` (hoisted case)
    resolve(rootDir, "node_modules", `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath),
    // try to resolve from `node_modules` (hoisted case)
    resolve(rootDir, "node_modules", modulePath),
    // workspace directories
    resolve(workspaceDir, "node_modules", `${VUE_I18N_ROUTING_PKG}/node_modules`, modulePath),
    resolve(workspaceDir, "node_modules", modulePath)
  ];
  debug$8(`${VUE_ROUTER_BRIDGE_PKG} resolving from ...`, targets);
  return tryResolve(VUE_ROUTER_BRIDGE_PKG, targets, pkgMgr);
}
async function resolveVueI18nRoutingAlias(pkgModulesDir2, nuxt, pkgMgr) {
  const { rootDir, workspaceDir } = nuxt.options;
  const modulePath = `${VUE_I18N_ROUTING_PKG}/dist/vue-i18n-routing.mjs`;
  const targets = [
    // for Nuxt layer
    ...getLayerRootDirs(nuxt).map((root) => resolve(root, "node_modules", modulePath)),
    // try to resolve from `node_modules/@nuxtjs/i18n` (not hoisted case)
    resolve(pkgModulesDir2, modulePath),
    // try to resolve from `node_modules` (hoisted case)
    resolve(rootDir, "node_modules", modulePath),
    // workspace directories
    resolve(workspaceDir, "node_modules", modulePath)
  ];
  debug$8(`${VUE_I18N_ROUTING_PKG} resolving from ...`, targets);
  return tryResolve(VUE_I18N_ROUTING_PKG, targets, pkgMgr);
}

const debug$7 = createDebug("@nuxtjs/i18n:layers");
const checkLayerOptions = (options, nuxt) => {
  const logger = useLogger(NUXT_I18N_MODULE_ID);
  const project = nuxt.options._layers[0];
  const layers = nuxt.options._layers;
  for (const layer of layers) {
    const layerI18n = getLayerI18n(layer);
    if (layerI18n == null)
      continue;
    const configLocation = project.config.rootDir === layer.config.rootDir ? "project layer" : "extended layer";
    const layerHint = `In ${configLocation} (\`${resolve(project.config.rootDir, layer.configFile)}\`) -`;
    try {
      if (layerI18n.lazy && !layerI18n.langDir) {
        throw new Error("When using the `lazy` option you must also set the `langDir` option.");
      }
      if (layerI18n.langDir) {
        const locales = layerI18n.locales || [];
        if (!locales.length || locales.some((locale) => isString(locale))) {
          throw new Error("When using the `langDir` option the `locales` must be a list of objects.");
        }
        if (isString(layerI18n.langDir) && isAbsolute(layerI18n.langDir)) {
          logger.warn(
            `${layerHint} \`langDir\` is set to an absolute path (\`${layerI18n.langDir}\`) but should be set a path relative to \`srcDir\` (\`${layer.config.srcDir}\`). Absolute paths will not work in production, see https://v8.i18n.nuxtjs.org/options/lazy#langdir for more details.`
          );
        }
        for (const locale of locales) {
          if (isString(locale) || !(locale.file || locale.files)) {
            throw new Error(
              `All locales must have the \`file\` or \`files\` property set when using \`langDir\`.
Found none in:
${JSON.stringify(locale, null, 2)}.`
            );
          }
        }
      }
    } catch (err) {
      if (!(err instanceof Error))
        throw err;
      throw new Error(formatMessage(`${layerHint} ${err.message}`));
    }
  }
};
const applyLayerOptions = (options, nuxt) => {
  const project = nuxt.options._layers[0];
  const layers = nuxt.options._layers;
  const resolvedLayerPaths = layers.map((l) => resolve(project.config.rootDir, l.config.rootDir));
  debug$7("using layers at paths", resolvedLayerPaths);
  const mergedLocales = mergeLayerLocales(options, nuxt);
  debug$7("merged locales", mergedLocales);
  options.locales = mergedLocales;
};
const mergeLayerPages = (analyzer, nuxt) => {
  const project = nuxt.options._layers[0];
  const layers = nuxt.options._layers;
  if (layers.length === 1)
    return;
  for (const l of layers) {
    const lPath = resolve(project.config.rootDir, l.config.rootDir, l.config.dir?.pages ?? "pages");
    debug$7("mergeLayerPages: path ->", lPath);
    analyzer(lPath);
  }
};
const mergeLayerLocales = (options, nuxt) => {
  debug$7("project layer `lazy` option", options.lazy);
  const projectLangDir = getProjectPath(nuxt, nuxt.options.srcDir);
  options.locales ?? (options.locales = []);
  const configs = nuxt.options._layers.filter((layer) => {
    const i18n = getLayerI18n(layer);
    return i18n?.locales != null;
  }).map((layer) => {
    const i18n = getLayerI18n(layer);
    return {
      ...i18n,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      langDir: resolve(layer.config.srcDir, i18n?.langDir ?? layer.config.srcDir),
      projectLangDir
    };
  });
  return mergeConfigLocales(configs);
};
const getLayerLangPaths = (nuxt) => {
  return nuxt.options._layers.filter((layer) => {
    const i18n = getLayerI18n(layer);
    return i18n?.langDir != null;
  }).map((layer) => {
    const i18n = getLayerI18n(layer);
    return resolve(layer.config.srcDir, i18n.langDir);
  });
};
async function resolveLayerVueI18nConfigInfo(nuxt, buildDir) {
  const logger = useLogger(NUXT_I18N_MODULE_ID);
  const layers = [...nuxt.options._layers];
  const project = layers.shift();
  const i18nLayers = [project, ...layers.filter((layer) => getLayerI18n(layer))];
  const resolved = await Promise.all(
    i18nLayers.map((layer) => {
      const i18n = getLayerI18n(layer);
      return [layer, i18n, resolveVueI18nConfigInfo(i18n || {}, buildDir, layer.config.rootDir)];
    }).map(async ([layer, i18n, resolver]) => {
      const res = await resolver;
      if (res == null && i18n?.vueI18n != null) {
        logger.warn(
          `Ignore Vue I18n configuration file does not exist at ${i18n.vueI18n} in ${layer.config.rootDir}. Skipping...`
        );
        return void 0;
      }
      return res;
    })
  );
  return resolved.filter((x) => x != null);
}

const debug$6 = createDebug("@nuxtjs/i18n:pages");
function setupPages(options, nuxt, additionalOptions = {
  trailingSlash: false
}) {
  function localizeRoutesPrefixable(opts) {
    return !options.differentDomains && DefaultLocalizeRoutesPrefixable(opts);
  }
  let includeUprefixedFallback = nuxt.options.ssr === false;
  nuxt.hook("nitro:init", () => {
    debug$6("enable includeUprefixedFallback");
    includeUprefixedFallback = true;
  });
  const pagesDir = nuxt.options.dir && nuxt.options.dir.pages ? nuxt.options.dir.pages : "pages";
  const srcDir = nuxt.options.srcDir;
  const { trailingSlash } = additionalOptions;
  debug$6(`pagesDir: ${pagesDir}, srcDir: ${srcDir}, tailingSlash: ${trailingSlash}`);
  extendPages((pages) => {
    debug$6("pages making ...", pages);
    const ctx = {
      stack: [],
      srcDir,
      pagesDir,
      pages: /* @__PURE__ */ new Map()
    };
    analyzeNuxtPages(ctx, pages);
    const analyzer = (pageDirOverride) => analyzeNuxtPages(ctx, pages, pageDirOverride);
    mergeLayerPages(analyzer, nuxt);
    const localizedPages = localizeRoutes(pages, {
      ...options,
      includeUprefixedFallback,
      localizeRoutesPrefixable,
      optionsResolver: getRouteOptionsResolver(ctx, options)
    });
    pages.splice(0, pages.length);
    pages.unshift(...localizedPages);
    debug$6("... made pages", pages);
  });
}
function analyzeNuxtPages(ctx, pages, pageDirOverride) {
  const pagesPath = resolve(ctx.srcDir, pageDirOverride ?? ctx.pagesDir);
  for (const page of pages) {
    if (page.file == null) {
      continue;
    }
    const splits = page.file.split(pagesPath);
    if (splits.length === 2 && splits[1]) {
      const { dir, name } = parse(splits[1]);
      let path = "";
      if (ctx.stack.length > 0) {
        path += `${dir.slice(1, dir.length)}/${name}`;
      } else {
        if (dir !== "/") {
          path += `${dir.slice(1, dir.length)}/`;
        }
        path += name;
      }
      const p = {
        inRoot: ctx.stack.length === 0,
        path
      };
      ctx.pages.set(page, p);
      if (page.children && page.children.length > 0) {
        ctx.stack.push(page.path);
        analyzeNuxtPages(ctx, page.children);
        ctx.stack.pop();
      }
    }
  }
}
function getRouteOptionsResolver(ctx, options) {
  const { pages, defaultLocale, customRoutes } = options;
  const useConfig = customRoutes === "config";
  debug$6("getRouteOptionsResolver useConfig", useConfig);
  return (route, localeCodes) => {
    const ret = useConfig ? getRouteOptionsFromPages(ctx, route, localeCodes, pages, defaultLocale) : getRouteOptionsFromComponent(route, localeCodes);
    debug$6("getRouteOptionsResolver resolved", route.path, route.name, ret);
    return ret;
  };
}
function resolveRoutePath(path) {
  const normalizePath = path.slice(1, path.length);
  const tokens = parseSegment(normalizePath);
  const routePath = getRoutePath(tokens);
  return routePath;
}
function getRouteOptionsFromPages(ctx, route, localeCodes, pages, defaultLocale) {
  const options = {
    locales: localeCodes,
    paths: {}
  };
  const pageMeta = ctx.pages.get(route);
  if (pageMeta == null) {
    console.warn(
      formatMessage(`Couldn't find AnalyzedNuxtPageMeta by NuxtPage (${route.path}), so no custom route for it`)
    );
    return options;
  }
  const pageOptions = pageMeta.path ? pages[pageMeta.path] : void 0;
  if (pageOptions === false) {
    return null;
  }
  if (!pageOptions) {
    return options;
  }
  options.locales = options.locales.filter((locale) => pageOptions[locale] !== false);
  for (const locale of options.locales) {
    const customLocalePath = pageOptions[locale];
    if (isString(customLocalePath)) {
      options.paths[locale] = resolveRoutePath(customLocalePath);
      continue;
    }
    const customDefaultLocalePath = pageOptions[defaultLocale];
    if (isString(customDefaultLocalePath)) {
      options.paths[locale] = resolveRoutePath(customDefaultLocalePath);
    }
  }
  return options;
}
function getRouteOptionsFromComponent(route, localeCodes) {
  debug$6("getRouteOptionsFromComponent", route);
  const file = route.component || route.file;
  if (!isString(file)) {
    return null;
  }
  const options = {
    locales: localeCodes,
    paths: {}
  };
  const componentOptions = readComponent(file);
  if (componentOptions == null) {
    return options;
  }
  if (componentOptions === false) {
    return null;
  }
  options.locales = componentOptions.locales || localeCodes;
  const locales = Object.keys(componentOptions.paths || {});
  for (const locale of locales) {
    const customLocalePath = componentOptions.paths[locale];
    if (isString(customLocalePath)) {
      options.paths[locale] = resolveRoutePath(customLocalePath);
    }
  }
  return options;
}
function readComponent(target) {
  let options = void 0;
  try {
    const content = readFileSync(target);
    const { descriptor } = parse$2(content);
    if (!content.includes(NUXT_I18N_COMPOSABLE_DEFINE_ROUTE)) {
      return options;
    }
    const desc = compileScript(descriptor, { id: target });
    const { scriptSetupAst, scriptAst } = desc;
    let extract = "";
    const genericSetupAst = scriptSetupAst || scriptAst;
    if (genericSetupAst) {
      const s = new MagicString(desc.loc.source);
      genericSetupAst.forEach((ast) => {
        walk(ast, {
          enter(_node) {
            const node = _node;
            if (node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === NUXT_I18N_COMPOSABLE_DEFINE_ROUTE) {
              const arg = node.arguments[0];
              if (arg.type === "ObjectExpression") {
                if (verifyObjectValue(arg.properties) && arg.start != null && arg.end != null) {
                  extract = s.slice(arg.start, arg.end);
                }
              } else if (arg.type === "BooleanLiteral" && arg.start != null && arg.end != null) {
                extract = s.slice(arg.start, arg.end);
              }
            }
          }
        });
      });
    }
    if (extract) {
      options = evalValue(extract);
    }
  } catch (e) {
    console.warn(formatMessage(`Couldn't read component data at ${target}: (${e.message})`));
  }
  return options;
}
function verifyObjectValue(properties) {
  let ret = true;
  for (const prop of properties) {
    if (prop.type === "ObjectProperty") {
      if (prop.key.type === "Identifier" && prop.key.name === "locales" || prop.key.type === "StringLiteral" && prop.key.value === "locales") {
        if (prop.value.type === "ArrayExpression") {
          ret = verifyLocalesArrayExpression(prop.value.elements);
        } else {
          console.warn(formatMessage(`'locale' value is required array`));
          ret = false;
        }
      } else if (prop.key.type === "Identifier" && prop.key.name === "paths" || prop.key.type === "StringLiteral" && prop.key.value === "paths") {
        if (prop.value.type === "ObjectExpression") {
          ret = verifyPathsObjectExpress(prop.value.properties);
        } else {
          console.warn(formatMessage(`'paths' value is required object`));
          ret = false;
        }
      }
    } else {
      console.warn(formatMessage(`'defineI18nRoute' is required object`));
      ret = false;
    }
  }
  return ret;
}
function verifyPathsObjectExpress(properties) {
  let ret = true;
  for (const prop of properties) {
    if (prop.type === "ObjectProperty") {
      if (prop.key.type === "Identifier" && prop.value.type !== "StringLiteral") {
        console.warn(formatMessage(`'paths.${prop.key.name}' value is required string literal`));
        ret = false;
      } else if (prop.key.type === "StringLiteral" && prop.value.type !== "StringLiteral") {
        console.warn(formatMessage(`'paths.${prop.key.value}' value is required string literal`));
        ret = false;
      }
    } else {
      console.warn(formatMessage(`'paths' is required object`));
      ret = false;
    }
  }
  return ret;
}
function verifyLocalesArrayExpression(elements) {
  let ret = true;
  for (const element of elements) {
    if (element?.type !== "StringLiteral") {
      console.warn(formatMessage(`required 'locales' value string literal`));
      ret = false;
    }
  }
  return ret;
}
function evalValue(value) {
  try {
    return new Function(`return (${value})`)();
  } catch (e) {
    console.error(formatMessage(`Cannot evaluate value: ${value}`));
    return;
  }
}

const VIRTUAL_PREFIX_HEX = "\0";

const debug$5 = createDebug("@nuxtjs/i18n:transform:macros");
const TransformMacroPlugin = createUnplugin((options) => {
  return {
    name: "nuxtjs:i18n-macros-transform",
    enforce: "post",
    transformInclude(id) {
      if (!id || id.startsWith(VIRTUAL_PREFIX_HEX)) {
        return false;
      }
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      return pathname.endsWith(".vue") || !!parseQuery(search).macro;
    },
    transform(code, id) {
      debug$5("transform", id);
      const s = new MagicString(code);
      const { search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      function result() {
        if (s.hasChanged()) {
          debug$5("transformed: id -> ", id);
          debug$5("transformed: code -> ", s.toString());
          return {
            code: s.toString(),
            map: options.sourcemap ? s.generateMap({ hires: true }) : void 0
          };
        }
      }
      const match = code.match(new RegExp(`\\b${NUXT_I18N_COMPOSABLE_DEFINE_ROUTE}\\s*\\(\\s*`));
      if (match?.[0]) {
        s.overwrite(match.index, match.index + match[0].length, `/*#__PURE__*/ false && ${match[0]}`);
      }
      if (!parseQuery(search).macro) {
        return result();
      }
      return result();
    }
  };
});

const debug$4 = createDebug("@nuxtjs/i18n:transform:resource");
const ResourcePlugin = createUnplugin((options) => {
  debug$4("options", options);
  return {
    name: "nuxtjs:i18n-resource",
    enforce: "post",
    transformInclude(id) {
      debug$4("transformInclude", id);
      if (!id || id.startsWith(VIRTUAL_PREFIX_HEX)) {
        return false;
      }
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      const query = parseQuery(search);
      return /\.([c|m]?[j|t]s)$/.test(pathname) && (!!query.locale || !!query.config);
    },
    transform(code, id) {
      debug$4("transform", id);
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      const query = parseQuery(search);
      const s = new MagicString(code);
      function result() {
        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap && !/\.([c|m]?ts)$/.test(pathname) ? s.generateMap({ hires: true }) : null
          };
        }
      }
      const pattern = query.locale ? NUXT_I18N_COMPOSABLE_DEFINE_LOCALE : NUXT_I18N_COMPOSABLE_DEFINE_CONFIG;
      const matches = code.matchAll(new RegExp(`\\b${pattern}\\s*`, "g"));
      for (const match of matches) {
        s.remove(match.index, match.index + match[0].length);
      }
      return result();
    }
  };
});

const debug$3 = createDebug("@nuxtjs/i18n:bundler");
async function extendBundler(nuxt, nuxtOptions) {
  const langPaths = getLayerLangPaths(nuxt);
  debug$3("langPaths -", langPaths);
  const i18nModulePaths = nuxtOptions?.i18nModules?.map((module) => resolve(nuxt.options._layers[0].config.rootDir, module.langDir ?? "")) ?? [];
  debug$3("i18nModulePaths -", i18nModulePaths);
  const localePaths = [...langPaths, ...i18nModulePaths];
  const macroOptions = {
    sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client
  };
  const resourceOptions = {
    sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client
  };
  try {
    const webpack = await import('webpack').then((m) => m.default || m);
    const webpackPluginOptions = {
      allowDynamic: true,
      runtimeOnly: nuxtOptions.bundle.runtimeOnly,
      compositionOnly: nuxtOptions.bundle.compositionOnly,
      jitCompilation: nuxtOptions.compilation.jit,
      dropMessageCompiler: nuxtOptions.compilation.jit ? nuxtOptions.bundle.dropMessageCompiler : false,
      strictMessage: nuxtOptions.compilation.strictMessage,
      escapeHtml: nuxtOptions.compilation.escapeHtml
    };
    if (localePaths.length > 0) {
      webpackPluginOptions.include = localePaths.map((x) => resolve(x, "./**"));
    }
    addWebpackPlugin(VueI18nWebpackPlugin(webpackPluginOptions));
    addWebpackPlugin(TransformMacroPlugin.webpack(macroOptions));
    addWebpackPlugin(ResourcePlugin.webpack(resourceOptions));
    extendWebpackConfig((config) => {
      config.plugins.push(
        new webpack.DefinePlugin(
          assign(
            getFeatureFlags({
              jit: nuxtOptions.compilation.jit,
              compositionOnly: nuxtOptions.bundle.compositionOnly,
              fullInstall: nuxtOptions.bundle.fullInstall,
              dropMessageCompiler: nuxtOptions.compilation.jit ? nuxtOptions.bundle.dropMessageCompiler : false
            }),
            {
              __DEBUG__: String(nuxtOptions.debug)
            }
          )
        )
      );
    });
  } catch (e) {
    debug$3(e.message);
  }
  const vitePluginOptions = {
    allowDynamic: true,
    runtimeOnly: nuxtOptions.bundle.runtimeOnly,
    compositionOnly: nuxtOptions.bundle.compositionOnly,
    fullInstall: nuxtOptions.bundle.fullInstall,
    jitCompilation: nuxtOptions.compilation.jit,
    dropMessageCompiler: nuxtOptions.compilation.jit ? nuxtOptions.bundle.dropMessageCompiler : false,
    strictMessage: nuxtOptions.compilation.strictMessage,
    escapeHtml: nuxtOptions.compilation.escapeHtml,
    defaultSFCLang: nuxtOptions.customBlocks.defaultSFCLang,
    globalSFCScope: nuxtOptions.customBlocks.globalSFCScope
  };
  if (localePaths.length > 0) {
    vitePluginOptions.include = localePaths.map((x) => resolve(x, "./**"));
  }
  addVitePlugin(VueI18nVitePlugin(vitePluginOptions));
  addVitePlugin(TransformMacroPlugin.vite(macroOptions));
  addVitePlugin(ResourcePlugin.vite(resourceOptions));
  extendViteConfig((config) => {
    if (config.define) {
      config.define["__DEBUG__"] = JSON.stringify(nuxtOptions.debug);
    } else {
      config.define = {
        __DEBUG__: JSON.stringify(nuxtOptions.debug)
      };
    }
    debug$3("vite.config.define", config.define);
  });
}
function getFeatureFlags({
  jit = true,
  compositionOnly = true,
  fullInstall = true,
  dropMessageCompiler = false
}) {
  return {
    __VUE_I18N_FULL_INSTALL__: String(fullInstall),
    __VUE_I18N_LEGACY_API__: String(!compositionOnly),
    __INTLIFY_PROD_DEVTOOLS__: "false",
    __INTLIFY_JIT_COMPILATION__: String(jit),
    __INTLIFY_DROP_MESSAGE_COMPILER__: String(dropMessageCompiler)
  };
}

const debug$2 = createDebug("@nuxtjs/i18n:nitro");
async function setupNitro(nuxt, nuxtOptions) {
  if (nuxt.options.ssr) {
    if (!nuxt.options.nitro) {
      nuxt.options.nitro = {};
    }
    const nitroConfig = nuxt.options.nitro;
    nitroConfig.replace = assign(
      nitroConfig.replace || {},
      getFeatureFlags({
        jit: nuxtOptions.compilation.jit,
        compositionOnly: nuxtOptions.bundle.compositionOnly,
        fullInstall: nuxtOptions.bundle.fullInstall,
        dropMessageCompiler: nuxtOptions.compilation.jit ? nuxtOptions.bundle.dropMessageCompiler : false
      })
    );
    nitroConfig.replace["__DEBUG__"] = String(nuxtOptions.debug);
    debug$2("nitro.replace", nitroConfig.replace);
  }
}

const debug$1 = createDebug("@nuxtjs/i18n:gen");
const generateVueI18nConfiguration = (config) => {
  return genDynamicImport(genImportSpecifier(config.meta, "config"), {
    comment: `webpackChunkName: ${config.meta.key}`
  });
};
function simplifyLocaleOptions(locales) {
  return locales.map(({ meta, ...locale }) => {
    if (locale?.files == null || locale?.files?.length === 0 && Object.keys(locale).filter((k) => !["iso", "code", "hashes", "types", "file", "files"].includes(k)).length === 0) {
      return locale.code;
    }
    return { ...locale, files: getLocalePaths(locale) };
  });
}
function generateLoaderOptions({ nuxtI18nOptions, vueI18nConfigPaths, localeInfo }) {
  debug$1("generateLoaderOptions: lazy", nuxtI18nOptions.lazy);
  const importMapper = /* @__PURE__ */ new Map();
  const importStrings = [];
  function generateLocaleImports(locale, meta) {
    if (importMapper.has(meta.key))
      return;
    const importSpecifier = genImportSpecifier(meta, "locale", { locale });
    const importer = { code: locale, key: meta.loadPath, load: "", cache: meta.file.cache ?? true };
    if (nuxtI18nOptions.lazy) {
      importer.load = genDynamicImport(importSpecifier, { comment: `webpackChunkName: "${meta.key}"` });
    } else {
      const assertFormat = meta.parsed.ext.slice(1);
      const importOptions = assertFormat ? { assert: { type: assertFormat } } : {};
      importStrings.push(genImport(importSpecifier, meta.key, importOptions));
      importer.load = `() => Promise.resolve(${meta.key})`;
    }
    importMapper.set(meta.key, {
      key: toCode(importer?.key),
      load: importer?.load,
      cache: toCode(importer?.cache)
    });
  }
  for (const locale of localeInfo) {
    locale?.meta?.forEach((meta) => generateLocaleImports(locale.code, meta));
  }
  const vueI18nConfigImports = vueI18nConfigPaths.reverse().filter((config) => config.absolute !== "").map((config) => generateVueI18nConfiguration(config));
  const localeMessages = localeInfo.map((locale) => [locale.code, locale.meta?.map((meta) => importMapper.get(meta.key))]);
  const generatedNuxtI18nOptions = {
    ...nuxtI18nOptions,
    locales: simplifyLocaleOptions(nuxtI18nOptions?.locales ?? [])
  };
  delete nuxtI18nOptions.vueI18n;
  const generated = {
    importStrings,
    localeMessages,
    nuxtI18nOptions: generatedNuxtI18nOptions,
    vueI18nConfigs: vueI18nConfigImports
  };
  debug$1("generate code", generated);
  return generated;
}
function genImportSpecifier({ loadPath, path, parsed, hash, type }, resourceType, query = {}) {
  if (!EXECUTABLE_EXTENSIONS.includes(parsed.ext))
    return loadPath;
  if (resourceType != null && type === "unknown") {
    throw new Error(`'unknown' type in '${path}'.`);
  }
  if (resourceType === "locale") {
    return withQuery(loadPath, type === "dynamic" ? { hash, ...query } : {});
  }
  if (resourceType === "config") {
    return withQuery(loadPath, { hash, ...query, ...{ config: 1 } });
  }
  return loadPath;
}

const debug = createDebug("@nuxtjs/i18n:module");
const module = defineNuxtModule({
  meta: {
    name: NUXT_I18N_MODULE_ID,
    configKey: "i18n",
    compatibility: {
      nuxt: "^3.0.0-rc.11",
      bridge: false
    }
  },
  defaults: DEFAULT_OPTIONS,
  async setup(i18nOptions, nuxt) {
    const logger = useLogger(NUXT_I18N_MODULE_ID);
    const options = i18nOptions;
    applyOptionOverrides(options, nuxt);
    debug("options", options);
    if (options.experimental.jsTsFormatResource) {
      logger.warn("JS / TS extension format is an experimental feature");
    }
    if (!options.compilation.jit) {
      logger.warn(
        `Opt-out JIT compilation. It's necessary to pre-compile locale messages that are not managed by the nuxt i18n module (e.g. in the case of importing from a specific URL, you will need to precompile them yourself.) And also, you need to understand that you cannot support use cases where you dynamically compose locale messages from the back-end via an API.`
      );
    }
    checkLayerOptions(options, nuxt);
    if (isNuxt2(nuxt)) {
      throw new Error(
        formatMessage(
          `We will release >=7.3 <8, See about GitHub Discussions https://github.com/nuxt-community/i18n-module/discussions/1287#discussioncomment-3042457: ${getNuxtVersion(
            nuxt
          )}`
        )
      );
    }
    if (!isNuxt3(nuxt)) {
      throw new Error(formatMessage(`Cannot support nuxt version: ${getNuxtVersion(nuxt)}`));
    }
    if (options.bundle.compositionOnly && options.types === "legacy") {
      throw new Error(
        formatMessage(
          `\`bundle.compositionOnly\` option and \`types\` option is conflicting: bundle.compositionOnly: ${options.bundle.compositionOnly}, types: ${JSON.stringify(options.types)}`
        )
      );
    }
    if (options.bundle.runtimeOnly && options.compilation.jit) {
      logger.warn(
        `\`bundle.runtimeOnly\` option and \`compilation.jit\` option is conflicting: bundle.runtimeOnly: ${options.bundle.runtimeOnly}, compilation.jit: ${JSON.stringify(
          options.compilation.jit
        )}`
      );
    }
    if (options.strategy === "no_prefix" && options.differentDomains) {
      logger.warn(
        "`differentDomains` option and `no_prefix` strategy are not compatible. Change strategy or disable `differentDomains` option."
      );
    }
    applyLayerOptions(options, nuxt);
    await mergeI18nModules(options, nuxt);
    nuxt.options.runtimeConfig.public.i18n = defu(nuxt.options.runtimeConfig.public.i18n, {
      experimental: options.experimental,
      baseUrl: options.baseUrl,
      locales: options.locales.reduce(
        (obj, locale) => {
          if (typeof locale === "string") {
            obj[locale] = { domain: void 0 };
          } else {
            obj[locale.code] = { domain: locale.domain };
          }
          return obj;
        },
        {}
      )
      // TODO: we should support more i18n module options. welcome PRs :-)
    });
    const normalizedLocales = getNormalizedLocales(options.locales);
    const localeCodes = normalizedLocales.map((locale) => locale.code);
    const localeInfo = await resolveLocales(
      resolve(nuxt.options.srcDir),
      normalizedLocales,
      relative(nuxt.options.buildDir, nuxt.options.srcDir)
    );
    debug("localeInfo", localeInfo);
    const vueI18nConfigPaths = await resolveLayerVueI18nConfigInfo(nuxt, nuxt.options.buildDir);
    debug("VueI18nConfigPaths", vueI18nConfigPaths);
    if (options.strategy !== "no_prefix" && localeCodes.length) {
      await setupPages(options, nuxt, { trailingSlash: options.trailingSlash });
    }
    await setupAlias(nuxt, options);
    addPlugin(resolve(runtimeDir, "plugins/i18n"));
    nuxt.options.alias["#i18n"] = resolve(distDir, "runtime/composables.mjs");
    nuxt.options.build.transpile.push("#i18n");
    addTemplate({
      filename: "i18n.internal.mjs",
      src: resolve(distDir, "runtime/internal.mjs")
    });
    addTemplate({
      filename: "i18n.utils.mjs",
      src: resolve(distDir, "runtime/utils.mjs")
    });
    addTemplate({
      filename: NUXT_I18N_TEMPLATE_OPTIONS_KEY,
      src: resolve(distDir, "runtime/templates/options.template.mjs"),
      write: true,
      options: {
        ...generateLoaderOptions({
          vueI18nConfigPaths,
          localeInfo,
          nuxtI18nOptions: options
        }),
        NUXT_I18N_MODULE_ID,
        localeCodes,
        nuxtI18nOptionsDefault: DEFAULT_OPTIONS,
        nuxtI18nInternalOptions: { __normalizedLocales: normalizedLocales },
        dev: nuxt.options.dev,
        isSSG: nuxt.options._generate,
        parallelPlugin: options.parallelPlugin
      }
    });
    if (!!options.dynamicRouteParams) {
      addPlugin(resolve(runtimeDir, "plugins/meta"));
    }
    const isLegacyMode = () => options.types === "legacy";
    addPlugin(resolve(runtimeDir, isLegacyMode() ? "plugins/legacy" : "plugins/composition"));
    nuxt.hook("prepare:types", ({ references }) => {
      const vueI18nTypeFilename = resolve(runtimeDir, "types");
      references.push({ path: resolve(nuxt.options.buildDir, vueI18nTypeFilename) });
    });
    nuxt.hook("build:manifest", (manifest) => {
      if (options.lazy) {
        const langFiles = localeInfo.flatMap((locale) => getLocaleFiles(locale)).map((x) => x.path);
        const langPaths = [...new Set(langFiles)];
        for (const key in manifest) {
          if (langPaths.some((x) => key.startsWith(x))) {
            manifest[key].prefetch = false;
            manifest[key].preload = false;
          }
        }
      }
    });
    await extendBundler(nuxt, options);
    await setupNitro(nuxt, options);
    const pkgMgr = await getPackageManagerType();
    const vueI18nPath = await resolveVueI18nAlias(pkgModulesDir, options, nuxt, pkgMgr);
    debug("vueI18nPath for auto-import", vueI18nPath);
    await addComponent({
      name: "NuxtLinkLocale",
      filePath: resolve(runtimeDir, "components/NuxtLinkLocale")
    });
    await addImports([
      { name: "useI18n", from: vueI18nPath },
      ...[
        "useRouteBaseName",
        "useLocalePath",
        "useLocaleRoute",
        "useSwitchLocalePath",
        "useLocaleHead",
        "useBrowserLocale",
        "useCookieLocale",
        NUXT_I18N_COMPOSABLE_DEFINE_ROUTE,
        NUXT_I18N_COMPOSABLE_DEFINE_LOCALE,
        NUXT_I18N_COMPOSABLE_DEFINE_CONFIG
      ].map((key) => ({
        name: key,
        as: key,
        from: resolve(runtimeDir, "composables")
      }))
    ]);
    nuxt.options.build.transpile.push("@nuxtjs/i18n");
    nuxt.options.build.transpile.push("@nuxtjs/i18n-edge");
    nuxt.options.vite.optimizeDeps = nuxt.options.vite.optimizeDeps || {};
    nuxt.options.vite.optimizeDeps.exclude = nuxt.options.vite.optimizeDeps.exclude || [];
    nuxt.options.vite.optimizeDeps.exclude.push("vue-i18n");
  }
});

export { module as default };
